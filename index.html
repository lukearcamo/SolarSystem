<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SolarSystem</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <style>
        body { margin: 0; }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #canvas:focus { outline: none; }
        #overlay {
            position: absolute;
            left: 10px;
            top: 10px;
            padding: 10px;
            background-color: rgba(5, 5, 5, 0.7);
            font-family: Verdana;
            color: white;
            font-size: 12px;
        }
        #command {
            background-color: black;
            color: white;
            border: 1px solid white;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border: 1px solid red;
        }
    </style>
    <body>
        <canvas id="canvas" tabindex="0" width="1280" height="720"></canvas>
        <div id="overlay">
            <div>XYZ: <span id="coords"></span></div>
            <div>FPS: <span id="fps"></span></div>
            <div>Renderer: <span id="renderer"></span></div>
            <hr>
            <div>Command: <input type="text" id="command"></input></div>
            <div>Output: <span id="output"></span></div>
            <div>Debug: <span id="debug"></span></div>
            <hr>
            <div>t: <span id="time"></span></div>
            <br>
            <div>x: <span id="position"></span></div>
            <br>
            <div>v: <span id="velocity"></span></div>
            <br>
            <div>a: <span id="acceleration"></span></div>
            <br>
            <div>Ï‰: <span id="angularVelocity"></span></div>
        </div>
        <div id="crosshair"></div>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
                }
            }
        </script>
        <script type="module">
            // https://ssd.jpl.nasa.gov/planets/approx_pos.html
            // https://ssd.jpl.nasa.gov/tools/orbit_viewer.html
            // https://ssd.jpl.nasa.gov/planets/phys_par.html
            // https://ssd.jpl.nasa.gov/sats/elem/ DO NOT USE THIS ONE, IT HAS NO MEAN ANOMALY, use horizons instead

            // Asteroids:
            // https://nssdc.gsfc.nasa.gov/planetary/factsheet/asteroidfact.html
            // https://ssd.jpl.nasa.gov/tools/sbdb_lookup.html

            // Axial tilts taken from https://nssdc.gsfc.nasa.gov/planetary/planetfact.html

            // For satellites:
            // https://en.wikipedia.org/wiki/Orbital_elements#Orbit_prediction
            // Use mean orbit parameters
            // Get mean motion from horizons system
            // Create a new satellite class, use this approximate calculation method
            // All orbital parameters assumed to stay constant, except for mean anomaly since the satellite actually moves
            // Mean motion is the rate of change of mean anomaly 

            // Before we begin this, you need to split up your code into manageable modules
            // Constants & Utils module, Add a whole bunch of unit conversion constants & functions
            // - MB exclude mod function because it is only used in body
            // Body module, Ship module (detached from camera, so you can have multiple instances)
            // Controls module (key events, orbit controls, ship controls, switching between scenes? or put that in Main?)
            // Main: Setup, Orbit data, Setup two scenes, Two cameras
            // Unrelated: for Body, separate the matrix calculation from the ellipse update and sphere update

            // So notice how the grid jitters but not the geometries
            // This is because the grid is a vast object, unlike the planets/ship
            // In another experiment, the jitter stopped when the grid was replaced with just a single line, going from -1e6 to +1e6,
            // and centered upon the origin
            // GLSL matrices and attributes can only support a single-precision floats, so when you pass in vaster values, they fail.
            // By using floating origin and smaller vectors, you can avoid this
            // But ignore this, just copy the original ellipse stuff, eliminate the AU scale factor and just make 1 u = 1 m,
            // and when zooming in to ship level (not planet level) hide grid and mb all orbits

            // IRL FOV, narrowed down to screen, should be approx 45 deg
            // or mb use orthocamera for overview?

            // Instead of point particles, just improve highlights pointing system -- Toggle highlight for each & multiple planets
            
            // Next step: Trajectories
            // - https://levelup.gitconnected.com/the-two-body-problem-in-python-6bbe4a0b2f88
            // - https://en.wikipedia.org/wiki/Two-body_problem#Reduction_to_two_independent,_one-body_problems
            // - "two-body has closed solution" means still must use numerical integration to get closed formula for position
            // - https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
            // - No js implementation of numerical integration, so must code yourself somehow
            // - https://en.wikipedia.org/wiki/Linear_differential_equation#System_of_linear_differential_equations
            // - https://evgenii.com/files/2018/08/two-body-problem-simulator/the_complete_code/
            // Next step: Improve UI, better highlight system, add CSS2DRenderer labels, etc.
            // Optimize geometries
            // Improved command system,
            // - switch statements instead of if else if else?
            // - mb input js functions directly somehow, use console tho modules cannot expose global vars, idk
            // - Trajectories -- Just do regular https://en.wikipedia.org/wiki/Verlet_integration at first, then add https://en.wikipedia.org/wiki/Patched_conic_approximation
            // Next step: Satellites
            // Make the planets spin
            // Fuel for drive and thrusters, account for varying ship mass
            // Spheres of influence, Patched conic approx

            // Terminal: python -m http.server
            // Can close terminal panel
            // localhost:8000
            // Reopen terminal panel, Ctrl + C to end

            // FYI The imported consts are not highlighted because this is an HTML file
            // If u put this script into a separate js module file, it will work
            
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            // import * as Utils from "./utils.js";
            import { G, AU_TO_m, TO_RADIANS, ms_TO_CENTURIES, j2000_UTC } from "./utils.js";
            import { Body } from "./body.js";
            import { Ship } from "./ship.js";
            import { bodies, numBodies, recalculateSystem } from "./system.js";

            // ===== Setup =====

            const canvas = document.getElementById("canvas");
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true }); // , precision: "highp", powerPreference: "high-performance" 
            window.addEventListener("resize", () => {
                renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            });

            const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 1, 1e15); // with log depth buffer
            camera.position.set(0, 0, 5 * AU_TO_m);

            const orbitControls = new OrbitControls(camera, canvas);
            orbitControls.target.set(0, 0, 0);
            orbitControls.update();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            // ===== Reusable geometries =====

            const hillMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 0.25, depthWrite: false });
            const soiMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, transparent: true, opacity: 0.25, depthWrite: false });

            // ===== Scene objects =====

            var grid = new THREE.PolarGridHelper(10 * AU_TO_m, 4, 10, 20, 0xffffff, 0xffffff);
            scene.add(grid);

            scene.add(new THREE.PointLight(0xffffff, 1));

            const transparentMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                depthWrite: false,
                // side: THREE.DoubleSide,
            });

            var referencePlane = new THREE.Mesh(new THREE.PlaneGeometry(20, 20).rotateX(-Math.PI / 2), transparentMat);
            referencePlane.visible = false;
            scene.add(referencePlane);

            const sphereGeo = new THREE.SphereGeometry(1, 24, 18);

            const hillSpheres = new THREE.InstancedMesh(sphereGeo, transparentMat, numBodies);
            scene.add(hillSpheres);
            hillSpheres.instanceMatrix.array.fill(0);

            const bodySpheres = new THREE.InstancedMesh(
                sphereGeo,
                new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }), // White; multiplied by instance color
                numBodies
            );
            scene.add(bodySpheres);

            var ellipseCurve = new THREE.EllipseCurve();
            var ellipsePoints = ellipseCurve.getPoints(1000);
            ellipsePoints.push(new THREE.Vector3(0.95, 0, 0)); // Perihelion (closest point to sun)

            const ellipseGeo = new THREE.BufferGeometry();
            ellipseGeo.setFromPoints(ellipsePoints);
            ellipseGeo.scale(AU_TO_m, AU_TO_m, AU_TO_m);
            ellipseGeo.rotateX(-Math.PI / 2);

            // I wanted to use instancing, but this is the best we have until instancing for lines is added
            const ellipses = [];
            for (var i = 0; i < numBodies; i++) {
                var e = new THREE.Line(ellipseGeo, new THREE.LineBasicMaterial());
                ellipses.push(e);
                scene.add(e);
            }

            // ===== Parse data and create ships =====

            const time = new Date();
            document.getElementById("time").innerHTML = time.toUTCString();
            var timeScale = 0;

            recalculateSystem(time, bodySpheres, ellipses);

            // https://en.wikipedia.org/wiki/Rings_of_Saturn#Subdivisions_and_structures_within_the_rings
            // Use a texture later on mb?
            // bodies["Saturn"].addRing(66.9e6, 140.18e6);
            var ringGeometry = new THREE.RingGeometry(66.9e6, 140.18e6, 30, 1).rotateX(-Math.PI / 2);
            ringGeometry.applyMatrix4(bodies["Saturn"].tiltMatrix);
            var ring = new THREE.Mesh(ringGeometry, new THREE.MeshBasicMaterial({ color: 0x665544, side: THREE.DoubleSide }));
            ring.position.copy(bodies["Saturn"].position);
            scene.add(ring);

            var ships = [new Ship(1e6)];
            var mainShip = ships[0];
            mainShip.position.copy(camera.position);
            // mainShip.position.copy(bodies["Jupiter"].position);
            // mainShip.position.x += bodies["Jupiter"].radius + 10000; // And then if u set drive power to 6g, u cannot escape
            scene.add(mainShip);
            
            function newHUDPoint(color) {
                var point = new THREE.Sprite(new THREE.SpriteMaterial({
                    color,
                    sizeAttenuation: false,
                    depthTest: false,
                    depthWrite: false,
                }));
                point.scale.setScalar(0.02);
                point.visible = false;
                scene.add(point);
                return point;
            }
            
            const highlight = newHUDPoint(0xff0000);
            const velocityHUD = newHUDPoint(0x00cc00);
            const negativeVelocityHUD = newHUDPoint(0xcc0000);

            // radius -- 2000000000
            // If deltaT is 1 anyways, no need for catmull rom curve
            // mainShip.drive = true;
            // mainShip.velocity.set(100000000, 0, 0);
            // var points = mainShip.calculateTrajectory(1, 10000);
            // var trajectoryGeo = new THREE.BufferGeometry().setFromPoints(points);
            // var trajectory = new THREE.Line(trajectoryGeo, new THREE.LineBasicMaterial({ color: 0xffff00 }));
            // scene.add(trajectory);

            function vecToString(vector, precision=2) {
                return `[${(vector.x).toFixed(precision)}, ${(vector.y).toFixed(precision)}, ${(vector.z).toFixed(precision)}]`
            }

            // ===== Controls =====

            const commandInput = document.getElementById("command");

            window.addEventListener("keydown", e => {
                if (e.key == "/") {
                    commandInput.focus();
                    e.preventDefault();
                }
                if (!orbitControls.enabled && document.activeElement != commandInput) {
                    if (e.key == "w") { mainShip.angularVelocity.x -= 0.1; } // Pitch up
                    else if (e.key == "s") { mainShip.angularVelocity.x += 0.1; } // Pitch down
                    else if (e.key == "a") { mainShip.angularVelocity.y += 0.1; } // Yaw left
                    else if (e.key == "d") { mainShip.angularVelocity.y -= 0.1; } // Yaw right
                    else if (e.key == "ArrowLeft") { mainShip.angularVelocity.z += 0.1; } // Roll left
                    else if (e.key == "ArrowRight") { mainShip.angularVelocity.z -= 0.1; } // Roll right
                    else if (e.key == " ") { mainShip.drive = true; } // Drive

                    document.getElementById("angularVelocity").innerHTML = vecToString(mainShip.angularVelocity, 3);
                }
            });
            window.addEventListener("keyup", e => {
                if (!orbitControls.enabled && document.activeElement != commandInput) {
                    if (e.key == " ") { mainShip.drive = false; } // Release drive
                }
            });

            commandInput.addEventListener("change", e => {
                var args = commandInput.value.split(" ");
                
                if (orbitControls.enabled) {
                    if (args[0] == "grid") { grid.visible = (args[1] == "show"); }
                    else if (args[0] == "ecliptic") { referencePlane.visible = (args[1] == "show"); }
                    else if (args[0] == "profile") {
                        var distance = (args.length == 3 ? parseFloat(args[2]) : 20) * AU_TO_m;
                        var angle = parseFloat(args[1]) * TO_RADIANS;
                        camera.position.set(Math.cos(angle) * distance, 0, -Math.sin(angle) * distance);
                        orbitControls.target.set(0, 0, 0);
                        orbitControls.update();
                    }
                    else if (args[0] == "focus") {
                        if (args[1] == "ship") orbitControls.target.copy(mainShip.position);
                        else { orbitControls.target.copy(bodies[args[1]].position); }
                        camera.position.copy(orbitControls.target);
                        camera.position.y = 2 * AU_TO_m;
                        orbitControls.update();
                    }
                    else if (args[0] == "orbit") {
                        if (args[2] == "all") {
                            for (var i = 0; i < numBodies; i++) {
                                ellipses[i].visible = (args[1] == "show");
                            }
                        }
                        else {
                            var i = Object.values(bodies).indexOf(bodies[args[2]]);
                            ellipses[i].visible = (args[1] == "show");
                        }
                    }
                }
                
                // Change this later to not teleport once thrusters have been added
                // Like calculate which thrusters to use and for what duration
                if (args[0] == "focus") {
                    if (args[1] == "ship") mainShip.lookAt(mainShip.position);
                    else { mainShip.lookAt(bodies[args[1]].position); }
                }
                else if (args[0] == "highlight") {
                    if (args[1] == "none") { highlight.visible = false; }
                    else {
                        var body = bodies[args[2]];
                        highlight.visible = true;
                        highlight.position.copy(body.position);
                    }
                }
                else if (args[0] == "distance") {
                    var distance = bodies[args[1]].position.distanceTo(bodies[args[2]].position);
                    document.getElementById("output").innerHTML = distance;
                }
                else if (args[0] == "escapeVelocity") {
                    var distance = bodies[args[1]].position.distanceTo(mainShip.position);
                    var escapeVelocity = Math.sqrt(2 * G * bodies[args[1]].mass / distance);
                    document.getElementById("output").innerHTML = escapeVelocity;
                }
                else if (args[0] == "hillSphere") {
                    var i = Object.values(bodies).indexOf(bodies[args[2]]);
                    if (args[1] == "show") {
                        var hs = bodies[args[2]].hillSphere();
                        var matrix = new THREE.Matrix4().makeScale(hs, hs, hs).setPosition(bodies[args[2]].position);
                        hillSpheres.setMatrixAt(i, matrix);
                    }
                    else {
                        hillSpheres.setMatrixAt(i, new THREE.Matrix4().makeScale(0, 0, 0));
                    }
                    hillSpheres.instanceMatrix.needsUpdate = true;
                }
                else if (args[0] == "tilt") {
                    var orbitalPole = new THREE.Vector3(0, 1, 0).applyMatrix4(bodies[args[1]].orbitMatrix);
                    var rotationalPole = new THREE.Vector3(0, 1, 0).applyMatrix4(bodies[args[1]].tiltMatrix);
                    var axialTilt = Math.acos(rotationalPole.dot(orbitalPole)) / TO_RADIANS;
                    document.getElementById("output").innerHTML = axialTilt.toFixed(2) + " Â°C";
                }
                else if (args[0] == "time") {
                    if (args[1] == "set") {
                        var importantTimes = {
                            "now": Date.now(), 
                            "j2000": j2000_UTC
                            // mb add option to define more user-defined points later?
                        };
                        if (args[2] in importantTimes) time.setTime(importantTimes[args[2]]);
                        else time.setTime(Date.parse(args[2]));
                    }
                    else if (args[1] == "add") {
                        const units = { y: "etUTCFullYear", d: "etUTCDate", h: "etUTCHours", m: "etUTCMinutes", s: "etUTCSeconds" };
                        for (var i = 2; i < args.length; i++) {
                            var fn = units[args[i].slice(-1)];
                            time["s" + fn](time["g" + fn]() + parseFloat(args[i].slice(0, -1)));
                        }
                    }
                    else if (args[1] == "speed") {
                        timeScale = parseFloat(args[2]); // Wouldnt it be better to use setInterval instead of relying on animation rate?
                    }
                    recalculateSystem(time, bodySpheres, ellipses);
                    document.getElementById("time").innerHTML = time.toUTCString();
                }
                else if (args[0] == "controls") {
                    if (args[1] == "ship") {
                        orbitControls.enabled = false;

                        velocityHUD.visible = true;
                        negativeVelocityHUD.visible = true;
                        grid.visible = false;

                        // camera.position.set(0, 0, 500); // Third person
                        camera.position.set(0, 0, 0); // First person
                        camera.quaternion.set(0, 1, 0, 0);
                        mainShip.add(camera);
                    }
                    else if (args[1] == "orbit") {
                        orbitControls.enabled = true;

                        velocityHUD.visible = false;
                        negativeVelocityHUD.visible = false;
                        grid.visible = true;

                        camera.position.set(0, 3 * AU_TO_m, 0);
                        orbitControls.target.set(0, 0, 0);
                        camera.removeFromParent(); // OrbitControls requires camera to have no parent or scene parent
                    }
                }
                else if (args[0] == "flip") { // Change this later to not teleport once thrusters have been added
                    var direction = new THREE.Vector3();
                    mainShip.getWorldDirection(direction);
                    mainShip.lookAt(direction.negate().add(mainShip.position));
                }

                commandInput.value = "";
                commandInput.blur();
            });

            // ===== Render loop =====

            var prevFrameTime = 0;
            function animate(now) {
                var deltaTime = document.hasFocus() ? now - prevFrameTime : 1000/60; // ms
                prevFrameTime = now;
                document.getElementById("fps").innerHTML = Math.round(1000 / deltaTime);
                document.getElementById("coords").innerHTML = vecToString(camera.position);
                document.getElementById("renderer").innerHTML = `[Geometries: ${renderer.info.memory.geometries}, Calls: ${renderer.info.render.calls}, Triangles: ${renderer.info.render.triangles}, Frame: ${renderer.info.render.frame}]`;
                // document.getElementById("debug").innerHTML = `[Debug: ${0}]`;
                
                if (timeScale != 0) {
                    time.setMilliseconds(time.getMilliseconds() + deltaTime * timeScale);
                    recalculateSystem(time, bodySpheres, ellipses);
                    document.getElementById("time").innerHTML = time.toUTCString();
                }

                mainShip.update(deltaTime / 1000, bodies); // 1/60 s IRL = 1/60 s SIM
                
                if (!orbitControls.enabled) {
                    velocityHUD.position.copy(mainShip.position).add(mainShip.velocity);
                    negativeVelocityHUD.position.copy(mainShip.position).sub(mainShip.velocity);
                }
                var v = mainShip.velocity.length();
                var a = mainShip.acceleration.length();
                document.getElementById("position").innerHTML = vecToString(mainShip.position);
                document.getElementById("velocity").innerHTML = vecToString(mainShip.velocity) + `<br>
                                                                &emsp; ${v.toFixed(2)} m/s<br>
                                                                &emsp; ${(v / 299792458 * 100).toFixed(2)}% c`;
                document.getElementById("acceleration").innerHTML = vecToString(mainShip.acceleration) + `<br>
                                                                &emsp; ${(a / 9.81).toFixed(2)} g`;

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        </script>
    </body>
</html>